// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/birdayz/kstreams/internal/runtime (interfaces: StringInputProcessor,StringBatchInputProcessor,RawRecordProcessor,BatchRawRecordProcessor,Flusher,Node)
//
// Generated by this command:
//
//	mockgen -destination=mock_runtime_test.go -package=runtime . StringInputProcessor,StringBatchInputProcessor,RawRecordProcessor,BatchRawRecordProcessor,Flusher,Node
//

// Package runtime is a generated GoMock package.
package runtime

import (
	context "context"
	reflect "reflect"

	kgo "github.com/twmb/franz-go/pkg/kgo"
	gomock "go.uber.org/mock/gomock"
)

// MockStringInputProcessor is a mock of StringInputProcessor interface.
type MockStringInputProcessor[K any, V any] struct {
	ctrl     *gomock.Controller
	recorder *MockStringInputProcessorMockRecorder[K, V]
	isgomock struct{}
}

// MockStringInputProcessorMockRecorder is the mock recorder for MockStringInputProcessor.
type MockStringInputProcessorMockRecorder[K any, V any] struct {
	mock *MockStringInputProcessor[K, V]
}

// NewMockStringInputProcessor creates a new mock instance.
func NewMockStringInputProcessor[K any, V any](ctrl *gomock.Controller) *MockStringInputProcessor[K, V] {
	mock := &MockStringInputProcessor[K, V]{ctrl: ctrl}
	mock.recorder = &MockStringInputProcessorMockRecorder[K, V]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStringInputProcessor[K, V]) EXPECT() *MockStringInputProcessorMockRecorder[K, V] {
	return m.recorder
}

// Process mocks base method.
func (m *MockStringInputProcessor[K, V]) Process(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Process", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// Process indicates an expected call of Process.
func (mr *MockStringInputProcessorMockRecorder[K, V]) Process(arg0, arg1, arg2 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Process", reflect.TypeOf((*MockStringInputProcessor[K, V])(nil).Process), arg0, arg1, arg2)
}

// MockStringBatchInputProcessor is a mock of StringBatchInputProcessor interface.
type MockStringBatchInputProcessor[K any, V any] struct {
	ctrl     *gomock.Controller
	recorder *MockStringBatchInputProcessorMockRecorder[K, V]
	isgomock struct{}
}

// MockStringBatchInputProcessorMockRecorder is the mock recorder for MockStringBatchInputProcessor.
type MockStringBatchInputProcessorMockRecorder[K any, V any] struct {
	mock *MockStringBatchInputProcessor[K, V]
}

// NewMockStringBatchInputProcessor creates a new mock instance.
func NewMockStringBatchInputProcessor[K any, V any](ctrl *gomock.Controller) *MockStringBatchInputProcessor[K, V] {
	mock := &MockStringBatchInputProcessor[K, V]{ctrl: ctrl}
	mock.recorder = &MockStringBatchInputProcessorMockRecorder[K, V]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStringBatchInputProcessor[K, V]) EXPECT() *MockStringBatchInputProcessorMockRecorder[K, V] {
	return m.recorder
}

// Process mocks base method.
func (m *MockStringBatchInputProcessor[K, V]) Process(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Process", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// Process indicates an expected call of Process.
func (mr *MockStringBatchInputProcessorMockRecorder[K, V]) Process(arg0, arg1, arg2 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Process", reflect.TypeOf((*MockStringBatchInputProcessor[K, V])(nil).Process), arg0, arg1, arg2)
}

// ProcessBatch mocks base method.
func (m *MockStringBatchInputProcessor[K, V]) ProcessBatch(ctx context.Context, keys, values []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProcessBatch", ctx, keys, values)
	ret0, _ := ret[0].(error)
	return ret0
}

// ProcessBatch indicates an expected call of ProcessBatch.
func (mr *MockStringBatchInputProcessorMockRecorder[K, V]) ProcessBatch(ctx, keys, values any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessBatch", reflect.TypeOf((*MockStringBatchInputProcessor[K, V])(nil).ProcessBatch), ctx, keys, values)
}

// MockRawRecordProcessor is a mock of RawRecordProcessor interface.
type MockRawRecordProcessor struct {
	ctrl     *gomock.Controller
	recorder *MockRawRecordProcessorMockRecorder
	isgomock struct{}
}

// MockRawRecordProcessorMockRecorder is the mock recorder for MockRawRecordProcessor.
type MockRawRecordProcessorMockRecorder struct {
	mock *MockRawRecordProcessor
}

// NewMockRawRecordProcessor creates a new mock instance.
func NewMockRawRecordProcessor(ctrl *gomock.Controller) *MockRawRecordProcessor {
	mock := &MockRawRecordProcessor{ctrl: ctrl}
	mock.recorder = &MockRawRecordProcessorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRawRecordProcessor) EXPECT() *MockRawRecordProcessorMockRecorder {
	return m.recorder
}

// Process mocks base method.
func (m_2 *MockRawRecordProcessor) Process(ctx context.Context, m *kgo.Record) error {
	m_2.ctrl.T.Helper()
	ret := m_2.ctrl.Call(m_2, "Process", ctx, m)
	ret0, _ := ret[0].(error)
	return ret0
}

// Process indicates an expected call of Process.
func (mr *MockRawRecordProcessorMockRecorder) Process(ctx, m any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Process", reflect.TypeOf((*MockRawRecordProcessor)(nil).Process), ctx, m)
}

// MockBatchRawRecordProcessor is a mock of BatchRawRecordProcessor interface.
type MockBatchRawRecordProcessor struct {
	ctrl     *gomock.Controller
	recorder *MockBatchRawRecordProcessorMockRecorder
	isgomock struct{}
}

// MockBatchRawRecordProcessorMockRecorder is the mock recorder for MockBatchRawRecordProcessor.
type MockBatchRawRecordProcessorMockRecorder struct {
	mock *MockBatchRawRecordProcessor
}

// NewMockBatchRawRecordProcessor creates a new mock instance.
func NewMockBatchRawRecordProcessor(ctrl *gomock.Controller) *MockBatchRawRecordProcessor {
	mock := &MockBatchRawRecordProcessor{ctrl: ctrl}
	mock.recorder = &MockBatchRawRecordProcessorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBatchRawRecordProcessor) EXPECT() *MockBatchRawRecordProcessorMockRecorder {
	return m.recorder
}

// Process mocks base method.
func (m_2 *MockBatchRawRecordProcessor) Process(ctx context.Context, m *kgo.Record) error {
	m_2.ctrl.T.Helper()
	ret := m_2.ctrl.Call(m_2, "Process", ctx, m)
	ret0, _ := ret[0].(error)
	return ret0
}

// Process indicates an expected call of Process.
func (mr *MockBatchRawRecordProcessorMockRecorder) Process(ctx, m any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Process", reflect.TypeOf((*MockBatchRawRecordProcessor)(nil).Process), ctx, m)
}

// ProcessBatch mocks base method.
func (m *MockBatchRawRecordProcessor) ProcessBatch(ctx context.Context, records []*kgo.Record) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProcessBatch", ctx, records)
	ret0, _ := ret[0].(error)
	return ret0
}

// ProcessBatch indicates an expected call of ProcessBatch.
func (mr *MockBatchRawRecordProcessorMockRecorder) ProcessBatch(ctx, records any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessBatch", reflect.TypeOf((*MockBatchRawRecordProcessor)(nil).ProcessBatch), ctx, records)
}

// MockFlusher is a mock of Flusher interface.
type MockFlusher struct {
	ctrl     *gomock.Controller
	recorder *MockFlusherMockRecorder
	isgomock struct{}
}

// MockFlusherMockRecorder is the mock recorder for MockFlusher.
type MockFlusherMockRecorder struct {
	mock *MockFlusher
}

// NewMockFlusher creates a new mock instance.
func NewMockFlusher(ctrl *gomock.Controller) *MockFlusher {
	mock := &MockFlusher{ctrl: ctrl}
	mock.recorder = &MockFlusherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFlusher) EXPECT() *MockFlusherMockRecorder {
	return m.recorder
}

// Flush mocks base method.
func (m *MockFlusher) Flush(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Flush", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Flush indicates an expected call of Flush.
func (mr *MockFlusherMockRecorder) Flush(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Flush", reflect.TypeOf((*MockFlusher)(nil).Flush), arg0)
}

// MockNode is a mock of Node interface.
type MockNode struct {
	ctrl     *gomock.Controller
	recorder *MockNodeMockRecorder
	isgomock struct{}
}

// MockNodeMockRecorder is the mock recorder for MockNode.
type MockNodeMockRecorder struct {
	mock *MockNode
}

// NewMockNode creates a new mock instance.
func NewMockNode(ctrl *gomock.Controller) *MockNode {
	mock := &MockNode{ctrl: ctrl}
	mock.recorder = &MockNodeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNode) EXPECT() *MockNodeMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockNode) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockNodeMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockNode)(nil).Close))
}

// Init mocks base method.
func (m *MockNode) Init() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init")
	ret0, _ := ret[0].(error)
	return ret0
}

// Init indicates an expected call of Init.
func (mr *MockNodeMockRecorder) Init() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockNode)(nil).Init))
}
