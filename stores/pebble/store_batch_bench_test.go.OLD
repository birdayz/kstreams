package pebble

import (
	"fmt"
	"testing"

	"github.com/birdayz/kstreams"
)

// BenchmarkPebbleBatchOperations demonstrates the performance improvement
// of batch operations vs individual operations.
//
// Run with: go test -bench=BenchmarkPebble -benchmem
func BenchmarkPebbleBatchOperations(b *testing.B) {
	testCases := []struct {
		name       string
		numRecords int
	}{
		{"100_records", 100},
		{"1000_records", 1000},
		{"10000_records", 10000},
	}

	for _, tc := range testCases {
		b.Run(fmt.Sprintf("IndividualSet_%s", tc.name), func(b *testing.B) {
			benchmarkIndividualSet(b, tc.numRecords)
		})

		b.Run(fmt.Sprintf("BatchSet_%s", tc.name), func(b *testing.B) {
			benchmarkBatchSet(b, tc.numRecords)
		})

		b.Run(fmt.Sprintf("IndividualGet_%s", tc.name), func(b *testing.B) {
			benchmarkIndividualGet(b, tc.numRecords)
		})

		b.Run(fmt.Sprintf("BatchGet_%s", tc.name), func(b *testing.B) {
			benchmarkBatchGet(b, tc.numRecords)
		})
	}
}

func benchmarkIndividualSet(b *testing.B, numRecords int) {
	store := createTestStore(b)
	defer store.Close()

	// Prepare test data
	kvs := make([]kstreams.KV[[]byte, []byte], numRecords)
	for i := 0; i < numRecords; i++ {
		kvs[i] = kstreams.KV[[]byte, []byte]{
			Key:   []byte(fmt.Sprintf("key-%d", i)),
			Value: []byte(fmt.Sprintf("value-%d", i)),
		}
	}

	b.ResetTimer()
	b.ReportAllocs()

	for i := 0; i < b.N; i++ {
		// Individual Set() calls
		for _, kv := range kvs {
			if err := store.Set(kv.Key, kv.Value); err != nil {
				b.Fatal(err)
			}
		}
	}

	b.StopTimer()

	// Calculate throughput
	totalOps := int64(b.N * numRecords)
	b.ReportMetric(float64(totalOps)/b.Elapsed().Seconds(), "ops/sec")
}

func benchmarkBatchSet(b *testing.B, numRecords int) {
	store := createTestStore(b)
	defer store.Close()

	// Prepare test data
	kvs := make([]kstreams.KV[[]byte, []byte], numRecords)
	for i := 0; i < numRecords; i++ {
		kvs[i] = kstreams.KV[[]byte, []byte]{
			Key:   []byte(fmt.Sprintf("key-%d", i)),
			Value: []byte(fmt.Sprintf("value-%d", i)),
		}
	}

	b.ResetTimer()
	b.ReportAllocs()

	for i := 0; i < b.N; i++ {
		// Single SetBatch() call
		if err := store.SetBatch(kvs); err != nil {
			b.Fatal(err)
		}
	}

	b.StopTimer()

	// Calculate throughput
	totalOps := int64(b.N * numRecords)
	b.ReportMetric(float64(totalOps)/b.Elapsed().Seconds(), "ops/sec")
}

func benchmarkIndividualGet(b *testing.B, numRecords int) {
	store := createTestStore(b)
	defer store.Close()

	// Populate store
	kvs := make([]kstreams.KV[[]byte, []byte], numRecords)
	for i := 0; i < numRecords; i++ {
		key := []byte(fmt.Sprintf("key-%d", i))
		value := []byte(fmt.Sprintf("value-%d", i))
		kvs[i] = kstreams.KV[[]byte, []byte]{Key: key, Value: value}
		store.Set(key, value)
	}

	keys := make([][]byte, numRecords)
	for i := 0; i < numRecords; i++ {
		keys[i] = []byte(fmt.Sprintf("key-%d", i))
	}

	b.ResetTimer()
	b.ReportAllocs()

	for i := 0; i < b.N; i++ {
		// Individual Get() calls
		for _, key := range keys {
			_, err := store.Get(key)
			if err != nil && err != kstreams.ErrKeyNotFound {
				b.Fatal(err)
			}
		}
	}

	b.StopTimer()

	totalOps := int64(b.N * numRecords)
	b.ReportMetric(float64(totalOps)/b.Elapsed().Seconds(), "ops/sec")
}

func benchmarkBatchGet(b *testing.B, numRecords int) {
	store := createTestStore(b)
	defer store.Close()

	// Populate store
	kvs := make([]kstreams.KV[[]byte, []byte], numRecords)
	for i := 0; i < numRecords; i++ {
		key := []byte(fmt.Sprintf("key-%d", i))
		value := []byte(fmt.Sprintf("value-%d", i))
		kvs[i] = kstreams.KV[[]byte, []byte]{Key: key, Value: value}
	}
	store.SetBatch(kvs)

	keys := make([][]byte, numRecords)
	for i := 0; i < numRecords; i++ {
		keys[i] = []byte(fmt.Sprintf("key-%d", i))
	}

	b.ResetTimer()
	b.ReportAllocs()

	for i := 0; i < b.N; i++ {
		// Single GetBatch() call
		_, err := store.GetBatch(keys)
		if err != nil {
			b.Fatal(err)
		}
	}

	b.StopTimer()

	totalOps := int64(b.N * numRecords)
	b.ReportMetric(float64(totalOps)/b.Elapsed().Seconds(), "ops/sec")
}

func createTestStore(b *testing.B) *pebbleStore {
	stateDir := b.TempDir()
	backend, err := newStore(stateDir, "test-store", 0)
	if err != nil {
		b.Fatalf("Failed to create store: %v", err)
	}
	return backend.(*pebbleStore)
}
