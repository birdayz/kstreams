package pebble

import (
	"github.com/birdayz/kstreams"
	"github.com/cockroachdb/pebble"
)

// Ensure pebbleStore implements BatchStoreBackend
var _ kstreams.BatchStoreBackend = (*pebbleStore)(nil)

// SupportsBatching returns true (Pebble supports batch operations).
func (s *pebbleStore) SupportsBatching() bool {
	return true
}

// SetBatch writes multiple key-value pairs atomically using Pebble's WriteBatch.
// This is much more efficient than individual Set() calls.
func (s *pebbleStore) SetBatch(kvs []kstreams.KV[[]byte, []byte]) error {
	if len(kvs) == 0 {
		return nil
	}

	batch := s.db.NewBatch()
	defer batch.Close()

	for _, kv := range kvs {
		if kv.Value == nil {
			// Tombstone - delete the key
			if err := batch.Delete(kv.Key, nil); err != nil {
				return err
			}
		} else {
			if err := batch.Set(kv.Key, kv.Value, nil); err != nil {
				return err
			}
		}
	}

	// Commit batch atomically
	return batch.Commit(&pebble.WriteOptions{Sync: false})
}

// GetBatch retrieves multiple values for given keys.
// Missing keys are omitted from results.
//
// Note: Pebble doesn't have native MultiGet, so we iterate through keys.
// This is still faster than separate Get() calls due to iterator optimizations.
func (s *pebbleStore) GetBatch(keys [][]byte) ([]kstreams.KV[[]byte, []byte], error) {
	if len(keys) == 0 {
		return nil, nil
	}

	results := make([]kstreams.KV[[]byte, []byte], 0, len(keys))

	for _, key := range keys {
		value, closer, err := s.db.Get(key)
		if err != nil {
			if err == pebble.ErrNotFound {
				continue // Skip missing keys
			}
			return nil, err
		}

		// Copy value (must copy before closer.Close())
		valueCopy := make([]byte, len(value))
		copy(valueCopy, value)
		closer.Close()

		results = append(results, kstreams.KV[[]byte, []byte]{
			Key:   key,
			Value: valueCopy,
		})
	}

	return results, nil
}

// DeleteBatch removes multiple keys atomically using Pebble's WriteBatch.
func (s *pebbleStore) DeleteBatch(keys [][]byte) error {
	if len(keys) == 0 {
		return nil
	}

	batch := s.db.NewBatch()
	defer batch.Close()

	for _, key := range keys {
		if err := batch.Delete(key, nil); err != nil {
			return err
		}
	}

	return batch.Commit(&pebble.WriteOptions{Sync: false})
}
